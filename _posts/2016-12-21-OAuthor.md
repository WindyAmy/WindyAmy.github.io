---
layout: post
title: 理解OAuth 2.0
date: 2016-12-21 
tags: 知识分享
---
> 本文引用地址[Artech](http://www.cnblogs.com/artech/p/oauth-01.html)博客园大神


# 背景 #

对于目前大部分Web应用来说，用户认证基本上都由应用自身来完成。具体来说，Web应用利用自身存储的用户凭证（基本上是用户名/密码）与用户提供的凭证进行比较进而确认其真实身份。但是这种由Web应用全权负责的认证方式会带来如下两个问题：

* 对于用户来说，他们不得不针对不同的访问Web应用提供不同的用户凭证。如果这些凭证具有完全不同的密码，我们没有多少人能够记得住，所以对于大部分整天畅游Internet的网友来说，我想他们在不同的网站注册的帐号都会采用相同的密码。密码的共享必然带来安全隐患，因为我们不能确定Web应用本身是否值得信任。“信任危机”来源于两个方面：首先是对“人品”缺乏信任，我们不知道他们是否具有保护用户敏感信息的意愿；其次是对“能力”缺乏信任，即我们不清楚他们是否有能力保护用户的敏感信息，对于知名网站泄露用户帐号信息的情况我们实在已经看的太多了。
*  对于Web应用的提供者来说，他们不得不对花费大量的时间、精力和资源来设计和开发自己的认证系统。在很多情况下，他们提供的是包含多个子系统的一整套解决方案，如果每个子系统均需要独立的认证，那么投入的成本可想而知。所以他们希望能够提供一个单一的“认证中心”来对整个“生态系统”提供认证，如果这个认证中心完全由第三方来免费提供，这无疑是最好的选择。
上面提出的这两点旨在说明一个问题：在Internet环境下，我们针对具体的Web应用设计独立的认证系统往往是一件“吃力不讨好”的事情。如果我们开发一个很小的Web应用，可能在实现用户认证功能上面花费的成本比实现应用自身业务功能的成本更大，而且还会因为“信任危机”导致潜在的使用者不敢注册。

在这种情况下，如果一个值得信任的第三方能够提供一种免费的认证服务，那么这两个问题均会迎刃而解。实际上目前这样的第三方认证服务很多，而且他们的提供者均为值得信赖的IT服务提供商，比如微软、Google、Facebook、Twitter，以及国内的新浪、腾讯、网易、人人和豆瓣等。就目前来说，这些第三方认证服务绝大部分均是基于OAuth 2.0设计的。

假设我有一件非常重要的文件存储与于瑞士银行的私有保险柜中，如果我需要委托某个人将他提取出来，除了将密码告诉他之外别无他法，但是OAuth的目的却是定义一种协议帮助资源的拥有者在不提供自身凭证的前提下授权第三方应用以他的名义存取受保护的资源。OAuth的全称为“Open Authorization”，所以它是一个开放的协议，目前最新的版本为2.0。

# OAuth 2.0的角色 #

获得资源拥有者授权的第三方应用请求受保护的资源采用的不是授权者的凭证，所有一个被称为Access Token的安全令牌。Access Token颁发过程会涉及到若干不同的“实体”，它们在这个过程中扮演者不同的角色，我们通过一个具体的场景来认识一下该过程中涉及到的几种角色。

假设我们开发了一个集成了新浪微博认证的用于发布打折商品消息的App，经过用户授权之后它可以调用新浪微博的Web API或者用户的电子邮箱地址并发布相应的打折消息。那么OAuth 2.0在这个场景中的作用就在于：用户授权该应用以自己的名义调用新浪微博的Web API获取自己的电子邮箱地址，整个过程涉及到如下4种角色。

* 资源拥有者（RO：Resource Owner）：资源的拥有者也是授权者，如果它是一个“人”，一般就是指最终用户。由于“资源”在这个场景中表示为用户的电子邮箱地址，所以资源拥有者自然就是指最终用户。
* 客户端应用（Client）：需要取得资源拥有者授权并最终访问受保护资源的应用，对于我们的场景来说，就是我们创建的App。
* 资源服务器（Resource Server）：最终承载资源的服务器，它一般体现为一个可被调用的Web API。对于我们提供的场景来说，客户端通过调用新浪微博得Web API获得用户的电子邮箱地址，所以新浪微博就是资源服务器。
* 授权服务器（Authorization Server）：它对用户（一般情况下为资源拥有者）和客户端应用实施认证，并在用户授权的情况下向客户端应用颁发Access Token。在我们提供的场景中，资源服务器和认证服务器合二为一，均为新浪微博。

## 处理流程 ##

虽然OAuth 2.0具体采用的执行流程因采用不同类型的授权方式而有所不同，但是整个流程大体上由客户端应用分别与资源拥有者、授权服务器和资源服务器进行的3轮交互来完成。这个过程基本上体现在下图中，这被称为经典的“Three-Legged OAuth”。
![sdfasdf]("http://images.cnitblog.com/blog/19327/201312/19090015-2751a5e0fb4e4fa98287188881de2bcb.png")

客户端应用试图获取某个受保护的资源，首先得取得资源拥有者的授权，所以第一轮消息交换旨在让客户端获得资源拥有者（即用户）的授权。客户端应用得到授权之后会得到一个被称为Authorization Grant的对象，该对象实际上就是一个简单的字符串用以表示成功取得了用户的授权。接下来客户端应用利用此Authorization Grant向授权服务取获取用于访问受保护资源所需的Access Token。在成功获得Access Token之后，客户端应用将其附加到针对资源服务器的请求中以获取它所需要的目标资源。



